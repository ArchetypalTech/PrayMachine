{%- macro direction(dir) -%}
  {%- if dir == "E" -%}
  zrk::DirectionType::East
  {%- elif dir == "S" -%}
  zrk::DirectionType::South
  {%- elif dir == "W" -%}
  zrk::DirectionType::West
  {%- elif dir == "N" -%}
  zrk::DirectionType::North
  {%- elif dir == "U" -%}
  zrk::DirectionType::Up
  {%- elif dir == "D" -%}
  zrk::DirectionType::Down
  {%- else -%}
  zrk::DirectionType::None
  {%- endif -%}
{%- endmacro direction -%}
{%- macro objectType(t) -%}
  {%- if t == "Path" -%}
  zrk::ObjectType::Path
  {%- elif t == "Window" -%}
  zrk::ObjectType::Window
  {%- elif t == "Ball" -%}
  zrk::ObjectType::Ball
  {%- elif t == "Door" -%}
  zrk::ObjectType::Door
  {%- elif t == "Stairs" -%}
  zrk::ObjectType::Stairs
  {%- elif t == "Place" -%}
  zrk::ObjectType::Place
  {%- elif t == "Troll" -%}
  zrk::ObjectType::Troll
  {%- elif t == "Chest" -%}
  zrk::ObjectType::Chest
  {%- elif t == "Box" -%}
  zrk::ObjectType::Box
  {%- elif t == "Matches" -%}
  zrk::ObjectType::Matches
  {%- elif t == "Can" -%}
  zrk::ObjectType::Can
  {%- elif t == "Dynamite" -%}
  zrk::ObjectType::Dynamite
  {%- elif t == "Boulder" -%}
  zrk::ObjectType::Boulder
  {%- elif t == "Bale" -%}
  zrk::ObjectType::Bale
  {%- elif t == "Petrol" -%}
  zrk::ObjectType::Petrol
  {%- else -%}
  zrk::ObjectType::None
{%- endif -%}
{%- endmacro objectType -%}
{%- macro actionType(t) -%}
  {%- if t == "Move" -%}
  zrk::ActionType::Move
  {%- elif t == "Look" -%}
  zrk::ActionType::Look
  {%- elif t == "Kick" -%}
  zrk::ActionType::Kick
  {%- elif t == "Hit" -%}
  zrk::ActionType::Hit
  {%- elif t == "Drink" -%}
  zrk::ActionType::Drink
  {%- elif t == "Fight" -%}
  zrk::ActionType::Fight
  {%- elif t == "Sleep" -%}
  zrk::ActionType::Sleep
  {%- elif t == "Smash" -%}
  zrk::ActionType::Smash
  {%- elif t == "Pray" -%}
  zrk::ActionType::Pray
  {%- elif t == "Open" -%}
  zrk::ActionType::Open
  {%- elif t == "Break" -%}
  zrk::ActionType::Break
  {%- elif t == "Burn" -%}
  zrk::ActionType::Burn
  {%- elif t == "Light" -%}
  zrk::ActionType::Light
  {%- elif t == "Spawn" -%}
  zrk::ActionType::Spawn
  {%- elif t == "Take" -%}
  zrk::ActionType::Take
  {%- elif t == "Help" -%}
  zrk::ActionType::Help
  {%- elif t == "Pour" -%}
  zrk::ActionType::Pour
  {%- elif t == "Follow" -%}
  zrk::ActionType::Follow
  {%- elif t == "Jump" -%}
  zrk::ActionType::Jump
  {%- elif t == "Block" -%}
  zrk::ActionType::Block
  {%- elif t == "Soak" -%}
  zrk::ActionType::Soak
  {%- elif t == "Empty" -%}
  zrk::ActionType::Empty
  {%- elif t == "Explode" -%}
  zrk::ActionType::Explode
  {%- elif t == "Disintegrate" -%}
  zrk::ActionType::Disintegrate
  {%- elif t == "Close" -%}
  zrk::ActionType::Close
  {%- else -%}
  zrk::ActionType::None
  {%- endif -%}
{%- endmacro actionType -%}
{%- macro materialType(m) -%}
  {%- if m == "Wood" -%}
  zrk::MaterialType::Wood
  {%- elif m == "Dirt" -%}
  zrk::MaterialType::Dirt
  {%- elif m == "Stone" -%}
  zrk::MaterialType::Stone
  {%- elif m == "Flesh" -%}
  zrk::MaterialType::Flesh
  {%- elif m == "Glass" -%}
  zrk::MaterialType::Glass
  {%- elif m == "IKEA" -%}
  zrk::MaterialType::IKEA
  {%- elif m == "Iron" -%}
  zrk::MaterialType::Iron
  {%- elif m == "Shit" -%}
  zrk::MaterialType::Shit
  {%- elif m == "Mud" -%}
  zrk::MaterialType::Mud
  {%- elif m == "Leather" -%}
  zrk::MaterialType::Leather
  {%- elif m == "Metal" -%}
  zrk::MaterialType::Metal
  {%- elif m == "TNT" -%}
  zrk::MaterialType::TNT
  {%- elif m == "Hay" -%}
  zrk::MaterialType::Hay
  {%- else -%}
  zrk::MaterialType::None
  {%- endif -%}
{%- endmacro materialType -%}
{%- macro roomType(r) -%}
  {%- if r == "WoodCabin" -%}
  zrk::RoomType::WoodCabin
  {%- elif r == "Store" -%}
  zrk::RoomType::Store
  {%- elif r == "Cavern" -%}
  zrk::RoomType::Cavern
  {%- elif r == "StoneCabin" -%}
  zrk::RoomType::StoneCabin
  {%- elif r == "Fort" -%}
  zrk::RoomType::Fort
  {%- elif r == "Room" -%}
  zrk::RoomType::Room
  {%- elif r == "Plain" -%}
  zrk::RoomType::Plain
  {%- elif r == "Mountains" -%}
  zrk::RoomType::Mountains
  {%- elif r == "Barn" -%}
  zrk::RoomType::Barn
  {%- elif r == "Forge" -%}
  zrk::RoomType::Forge
  {%- elif r == "Pass" -%}
  zrk::RoomType::Pass
  {%- elif r == "Alley" -%}
  zrk::RoomType::Alley
  {%- else -%}
  zrk::RoomType::None
  {%- endif -%}
{%- endmacro roomType -%}

#[dojo::interface]
trait ISpawner<T> {
    fn setup(ref world: IWorldDispatcher);
    fn spawn_player(ref world: IWorldDispatcher, pid: felt252, start_room: felt252);
}

#[dojo::contract]
pub mod spawner {
    use starknet::{ContractAddress, testing, get_caller_address};
    use core::byte_array::ByteArrayTrait;
    use core::array::ArrayTrait;
    use core::option::OptionTrait;
    use super::ISpawner;

    use the_oruggin_trail::models::{
        zrk_enums as zrk, 
        txtdef::{Txtdef}, 
        action::{Action}, 
        object::{Object}, 
        room::{Room}, 
        player::{Player},
        inventory::{Inventory}
    };

    use the_oruggin_trail::constants::zrk_constants as zc;
    use the_oruggin_trail::constants::zrk_constants::{roomid as rm, statusid as st};
    use the_oruggin_trail::lib::hash_utils::hashutils as h_util;

    #[abi(embed_v0)]
    impl SpawnerImpl of ISpawner<ContractState> {
        fn setup(ref world: IWorldDispatcher) {
            make_rooms(world, 23);
        }

        fn spawn_player(ref world: IWorldDispatcher, pid: felt252, start_room: felt252) {
            let player = Player{
                player_id: pid,
                player_adr: OTHER(),
                location: start_room,
                inventory: pid
            };

            let inv = Inventory {owner_id: pid, items: array![]};
            set!(world, (inv));
            set!(world, (player));
        }
    }

    fn OTHER() -> ContractAddress { starknet::contract_address_const::<0x2>() }

    fn store_objects(w: IWorldDispatcher, t: Array<Object>) {
        for o in t {
            set!(w, (o));
        }
    }

    fn store_actions(w: IWorldDispatcher, t: Array<Action>) {
        for o in t {
            set!(w, (o));
        }
    }

    fn store_places(w: IWorldDispatcher, t: Array<Room>) {
        for o in t {
            set!(w, (o));
        }
    }

    fn store_txt(world: IWorldDispatcher, id: felt252, ownedBy: felt252, val: ByteArray) {
        set!(world, (Txtdef { id: id, owner: ownedBy, text: val },));
    }

    // --------------------------------------------------------------------------------------------
    // GENERATED
    // --------------------------------------------------------------------------------------------

    fn make_rooms(w: IWorldDispatcher, pl: felt252) {
    {%- for room in levels[0].rooms %}
        // {{room.roomName}}
        let _  = gen_room_{{room.roomID}}(w, pl);
    {%- endfor %}
    }

    {% for room in levels[0].rooms %}
    // {{loop.index}}. {{room.roomName}}: {{room.roomDescription | linebreaks(to="\n") }}
    fn gen_room_{{room.roomID}}(w: IWorldDispatcher, playerid: felt252) {
      
        {%- if room.objects -%}
        {%- for object in room.objects -%}
        // object {{object.objID}}
        
        {%- if object.actions -%}
        {%- for action in object.actions -%}

        // action {{action.actionID}}
        let mut action_{{object.objID}}_{{action.actionID}} = Action{
            actionId: st::NONE, 
            actionType: {{ self::actionType(t=action.type) | trim }},  
            dBitTxt: "{{action.dBitText}}", enabled: {{action.enabled}}, 
            revertable: {{action.revertable}}, dBit: {{action.dBit}}, 
            affectsActionId: 0,
            affectedByActionId: 0
        };
        
        let action_id_{{object.objID}}_{{action.actionID}} = h_util::action_hash(@action_{{object.objID}}_{{action.actionID}} );
        action_{{object.objID}}_{{action.actionID}}.actionId = action_id_{{object.objID}}_{{action.actionID}};
        
        {% endfor -%}
        
        {% endif -%}
        

        {%if object.destination -%}
        let destination = "{{object.destination}}";
        let mut object_{{object.objID}} = Object{
            objectId: st::SETME, 
            objType: {{ self::objectType(t=object.type) | trim }},
            matType: {{ self::materialType(m=object.material) | trim }},
            dirType: {{ self::direction(dir=object.direction) | trim }},
            destId: h_util::str_hash(@destination),
            objectActionIds: array![{%- for action in object.actions -%}action_id_{{object.objID}}_{{action.actionID}},{%- endfor -%}],
            txtDefId: st::SETME 
        };
        {%- else -%}
        let mut object_{{object.objID}} = Object{
            objectId: st::SETME, 
            objType: {{ self::objectType(t=object.type) | trim }},
            matType: {{ self::materialType(m=object.material) | trim }},
            dirType: {{ self::direction(dir=object.direction) | trim }},
            destId: st::NONE,
            objectActionIds: array![{%- for action in object.actions -%}action_id_{{object.objID}}_{{action.actionID}},{%- endfor -%}],
            txtDefId: st::SETME 
        };
        {%- endif %}

        let object_id_{{object.objID}} = h_util::obj_hash(@object_{{object.objID}}); 
        object_{{object.objID}}.objectId = object_id_{{object.objID}};
        let object_desc: ByteArray = "{{ object.objDescription | linebreaks }}";
        let td_id_b = h_util::str_hash(@object_desc);
        object_{{object.objID}}.txtDefId = td_id_b;

        store_txt(w, td_id_b, object_id_{{object.objID}}, object_desc);

        
        {% endfor -%}

        {%- for object in room.objects -%}
        {%- if object.actions -%}
        {%- for action in object.actions -%}
        {%- if action.affectsAction -%}
        {# action_{{object.objID}}_{{action.actionID}}.affectsActionId = action_id_{{object.objID}}_{{ action.affectsAction.actionID }}; #}
        action_{{object.objID}}_{{action.actionID}}.affectsActionId = action_id_{{object.objID}}_{{ action.affectsAction }};
        {# action_{{object.objID}}_{{ action.affectsAction.actionID }}.affectedByActionId = action_id_{{object.objID}}_{{ action.actionID }}; #}
        action_{{object.objID}}_{{ action.affectsAction }}.affectedByActionId = action_id_{{object.objID}}_{{ action.actionID }};
        {%- endif -%}
        {% endfor -%}
        {%- endif -%}
        store_actions(w, array![{%- for action in object.actions -%}action_{{object.objID}}_{{action.actionID}},{%- endfor -%} ]);
        {% endfor %}

        {%- for object in room.objects -%}store_objects(w, array![object_{{object.objID}}]);{%- endfor -%}
        // store_objects(w, array![{%- for object in room.objects -%}object_{{object.objID}},{%- endfor -%}]);
        {%- endif %}
        
        // now store a room with all its shizzle
        let room_desc: ByteArray = "{{ room.roomDescription | linebreaks }}";
        let _txt_id = h_util::str_hash(@room_desc);
        let place_name: ByteArray = "{{room.roomName}}";
        let rmid = h_util::str_hash(@place_name);

        let mut place = Room{
            roomId: rmid,
            roomType: {{ self::roomType(r=room.roomType) | trim }},
            txtDefId: _txt_id,
            shortTxt: place_name,
            objectIds: array![{%- for id in room.objectIds -%}object_id_{{id}},{%- endfor -%}],
            dirObjIds: array![{%- for id in room.dirObjIds -%}object_id_{{id}},{%- endfor -%}],
            players: array![]
        };

        // set main description text in world store
        // for the place/area/room
        store_txt(w, _txt_id, rmid, room_desc);
        store_places(w, array![place]);
        
    }
    {%- endfor -%}
}
