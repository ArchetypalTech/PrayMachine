#[dojo::interface]
trait ISpawner<T> {
    fn setup(ref world: IWorldDispatcher);
}

// {{ levels[0] }}

#[dojo::contract]
pub mod spawner {
    use core::byte_array::ByteArrayTrait;
    use core::array::ArrayTrait;
    use core::option::OptionTrait;
    use super::ISpawner;

    use the_oruggin_trail::models::{
        zrk_enums as zrk, txtdef::{Txtdef}, action::{Action}, object::{Object}, room::{Room}
    };

    use the_oruggin_trail::constants::zrk_constants as zc;
    use the_oruggin_trail::constants::zrk_constants::{roomid as rm, statusid as st};

    use the_oruggin_trail::lib::hash_utils::hashutils as h_util;


    #[abi(embed_v0)]
    impl SpawnerImpl of ISpawner<ContractState> {
        fn setup(ref world: IWorldDispatcher) {
            make_rooms(world, 23);
        }
    }

    fn store_objects(w: IWorldDispatcher, t: Array<Object>) {
        let mut i = 0;
        while i < t.len() {
            let a: Object = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_actions(w: IWorldDispatcher, t: Array<Action>) {
        let mut i = 0;
        while i < t.len() {
            let a: Action = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_places(w: IWorldDispatcher, t: Array<Room>) {
        let mut i = 0;
        while i < t.len() {
            let a: Room = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_txt(world: IWorldDispatcher, id: felt252, ownedBy: felt252, val: ByteArray) {
        set!(world, (Txtdef { id: id, owner: ownedBy, text: val },));
    }


    // GENERATED


    fn make_rooms(w: IWorldDispatcher, pl: felt252) { // //pass
    {% for room in levels[0].rooms %}
        // {{room.roomName}}
        let _  = gen_room_{{room.roomID}}(w, pl);
    {% endfor %}
    }


    {% for room in levels[0].rooms %}
    // {{loop.index}}. {{room.roomName}}: {{room.roomDescription}}
    fn gen_room_{{room.roomID}}(w: IWorldDispatcher, playerid: felt252) {
        {% if room.exits %}
        {% for exit in room.exits %}
        // {{exit.exitID}} dir:{{exit.direction}} type:{{exit.type}} material:{{exit.material}} open:{{exit.isOpen}}
        let mut action_{{exit.exitID}} = Action{actionId: st::NONE, actionType: zrk::ActionType::Open, 
            dBitTxt: "the path winds east, it is open", enabled: true, 
            revertable: false, dBit: true, 
            affectsActionId: 0, affectedByActionId: 0};
        action_{{exit.exitID}}.actionId = h_util::action_hash(@action_{{exit.exitID}});
        {% endfor %}

        store_actions(w, array![{% for exit in room.exits %}action_{{exit.exitID}}{%if loop.last %}{% else %},{% endif %}{% endfor %} ]);
        
        {% endif %}
    
        
    }
    {% endfor %}
}
