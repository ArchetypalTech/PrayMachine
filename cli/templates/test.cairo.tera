#[dojo::interface]
trait ISpawner<T> {
    fn setup(ref world: IWorldDispatcher);
}

#[dojo::contract]
pub mod spawner {
    use core::byte_array::ByteArrayTrait;
    use core::array::ArrayTrait;
    use core::option::OptionTrait;
    use super::ISpawner;

    use the_oruggin_trail::models::{
        zrk_enums as zrk, txtdef::{Txtdef}, action::{Action}, object::{Object}, room::{Room}
    };

    use the_oruggin_trail::constants::zrk_constants as zc;
    use the_oruggin_trail::constants::zrk_constants::{roomid as rm, statusid as st};

    use the_oruggin_trail::lib::hash_utils::hashutils as h_util;


    #[abi(embed_v0)]
    impl SpawnerImpl of ISpawner<ContractState> {
        fn setup(ref world: IWorldDispatcher) {
            make_rooms(world, 23);
        }
    }

    fn store_objects(w: IWorldDispatcher, t: Array<Object>) {
        let mut i = 0;
        while i < t.len() {
            let a: Object = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_actions(w: IWorldDispatcher, t: Array<Action>) {
        let mut i = 0;
        while i < t.len() {
            let a: Action = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_places(w: IWorldDispatcher, t: Array<Room>) {
        let mut i = 0;
        while i < t.len() {
            let a: Room = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_txt(world: IWorldDispatcher, id: felt252, ownedBy: felt252, val: ByteArray) {
        set!(world, (Txtdef { id: id, owner: ownedBy, text: val },));
    }


    // GENERATED


    fn make_rooms(w: IWorldDispatcher, pl: felt252) { // //pass
    {% for room in levels[0].rooms %}
        // {{room.roomName}}
        let _  = gen_room_{{room.roomID}}(w, pl);
    {% endfor %}
    }


    {% for room in levels[0].rooms %}
    // {{loop.index}}. {{room.roomName}}: {{room.roomDescription}}
    fn gen_room_{{room.roomID}}(w: IWorldDispatcher, playerid: felt252) {
        {% if room.exits %}
        {% for exit in room.exits %}
        // {{exit.exitID}} dir:{{exit.direction}} type:{{exit.type}} material:{{exit.material}} open:{{exit.isOpen}}
        let mut action_{{exit.exitID}} = Action{actionId: st::NONE, actionType: zrk::ActionType::Open, 
            dBitTxt: "the path winds east, it is open", enabled: true, 
            revertable: false, dBit: true, 
            affectsActionId: 0, affectedByActionId: 0};
        let action_id = h_util::action_hash(@action_{{exit.exitID}});
        action_{{exit.exitID}}.actionId = action_id;

        
        let path_desc: ByteArray = "a path east leads upwards toward the mountains"; // TODO
        let td_id_p = h_util::str_hash(@path_desc); // text id
        let dest_name: ByteArray = "walking eagle pass"; // TODO
        let mut path_{{exit.exitID}} = Object{
            objectId: st::SETME, 
            objType: zrk::ObjectType::Path, 
            dirType: zrk::DirectionType::East, // TODO
            destId: h_util::str_hash(@dest_name), 
            matType: zrk::MaterialType::Dirt,
            objectActionIds: array![action_id],
            txtDefId: td_id_p 
         };

        let de_id = h_util::obj_hash(@path_{{exit.exitID}}); 
        path_{{exit.exitID}}.objectId = de_id;
        store_txt(w, td_id_p, de_id, path_desc);

        {% endfor %}

        store_actions(w, array![{% for exit in room.exits %}action_{{exit.exitID}}{%if loop.last %}{% else %},{% endif %}{% endfor %} ]);
        
        // now we have assembled the path objects and stored
        // their components we can store the paths themselves
        store_objects(w, array![{% for exit in room.exits %}path_{{exit.exitID}}{%if loop.last %}{% else %},{% endif %}{% endfor %} ]);
        {% endif %}

      
       
        
    }
    {% endfor %}
}
