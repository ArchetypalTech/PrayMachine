{% macro direction(dir) %}
  {% if dir == "E" %}
  zrk::DirectionType::East
  {% elif dir == "S" %}
  zrk::DirectionType::South
  {% elif dir == "W" %}
  zrk::DirectionType::West
  {% elif dir == "N" %}
  zrk::DirectionType::North
  {% else %}UNKNOWN DIRECTION
  {% endif %}
{% endmacro direction %}

{% macro objectType(t) %}
  {% if t == "path" %}
  zrk::ObjectType::Path
  {% elif t == "window" %}
  zrk::ObjectType::Window
  {% elif t == "ball" %}
  zrk::ObjectType::Ball
  {% else %}UNKNOWN OBJECT TYPE{% endif %}
{% endmacro objectType %}

{% macro materialType(m) %}
  {% if m == "dirt" %}
  zrk::MaterialType::Dirt
  {% elif m == "glass" %}
  zrk::MaterialType::Dirt
  {% else %}UNKNOWN MATERIAL TYPE{% endif %}
{% endmacro materialType %}


#[dojo::interface]
trait ISpawner<T> {
    fn setup(ref world: IWorldDispatcher);
}

#[dojo::contract]
pub mod spawner {
    use core::byte_array::ByteArrayTrait;
    use core::array::ArrayTrait;
    use core::option::OptionTrait;
    use super::ISpawner;

    use the_oruggin_trail::models::{
        zrk_enums as zrk, txtdef::{Txtdef}, action::{Action}, object::{Object}, room::{Room}
    };

    use the_oruggin_trail::constants::zrk_constants as zc;
    use the_oruggin_trail::constants::zrk_constants::{roomid as rm, statusid as st};

    use the_oruggin_trail::lib::hash_utils::hashutils as h_util;


    #[abi(embed_v0)]
    impl SpawnerImpl of ISpawner<ContractState> {
        fn setup(ref world: IWorldDispatcher) {
            make_rooms(world, 23);
        }
    }

    fn store_objects(w: IWorldDispatcher, t: Array<Object>) {
        let mut i = 0;
        while i < t.len() {
            let a: Object = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_actions(w: IWorldDispatcher, t: Array<Action>) {
        let mut i = 0;
        while i < t.len() {
            let a: Action = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_places(w: IWorldDispatcher, t: Array<Room>) {
        let mut i = 0;
        while i < t.len() {
            let a: Room = t.at(i).clone();
            set!(w, (a));
            i += 1 + i;
        }
    }

    fn store_txt(world: IWorldDispatcher, id: felt252, ownedBy: felt252, val: ByteArray) {
        set!(world, (Txtdef { id: id, owner: ownedBy, text: val },));
    }


    // GENERATED


    fn make_rooms(w: IWorldDispatcher, pl: felt252) { // //pass
    {% for room in levels[0].rooms %}
        // {{room.roomName}}
        let _  = gen_room_{{room.roomID}}(w, pl);
    {% endfor %}
    }

    {% for room in levels[0].rooms %}
    // {{loop.index}}. {{room.roomName}}: {{room.roomDescription}}
    fn gen_room_{{room.roomID}}(w: IWorldDispatcher, playerid: felt252) {
        {% if room.exits %}
        {% for exit in room.exits %}
        // {{exit.exitID}}
        // dir:{{exit.direction}} type:{{exit.type}} material:{{exit.material}} open:{{exit.isOpen}}
        let mut action_{{exit.exitID}} = Action{actionId: st::NONE, actionType: zrk::ActionType::Open, 
            dBitTxt: "{{exit.dBitText}}", enabled: {{exit.enabled}}, 
            revertable: {{exit.revertable}}, dBit: {{exit.isOpen}}, 
            affectsActionId: 0, // TODO ?
            affectedByActionId: 0 // TODO ?
        }; 
        let action_id = h_util::action_hash(@action_{{exit.exitID}});
        action_{{exit.exitID}}.actionId = action_id;

        
        let path_desc: ByteArray = "{{exit.description}}";
        let td_id_p = h_util::str_hash(@path_desc); // text id
        let dest_name: ByteArray = "{{exit.destination}}";
        let mut path_{{exit.exitID}} = Object{
            objectId: st::SETME, 
            objType: {{ self::objectType(t=exit.type)}} 
            dirType: {{ self::direction(dir=exit.direction) }},
            destId: h_util::str_hash(@dest_name), 
            matType: {{ self::materialType(m=exit.material) }},
            objectActionIds: array![action_id],
            txtDefId: td_id_p 
         };

        let de_id = h_util::obj_hash(@path_{{exit.exitID}}); 
        path_{{exit.exitID}}.objectId = de_id;
        store_txt(w, td_id_p, de_id, path_desc);

        {% endfor %}

        store_actions(w, array![{% for exit in room.exits %}action_{{exit.exitID}}{%if loop.last %}{% else %},{% endif %}{% endfor %} ]);
        
        // now we have assembled the path objects and stored
        // their components we can store the paths themselves
        store_objects(w, array![{% for exit in room.exits %}path_{{exit.exitID}}{%if loop.last %}{% else %},{% endif %}{% endfor %} ]);
        {% endif %}


        {% if room.objects %}
        {% for object in room.objects %}
        // object {{object.objID}}
        
        {% if object.actions %}
        {% for action in object.actions %}

        // action {{action.actionID}}
        let mut action_{{action.actionID}}_{{object.objID}} = Action{actionId: st::NONE, actionType: zrk::ActionType::Kick, 
            dBitTxt: "the ball bounces feebly and rolls into some dog shit. fun.", enabled: true, 
            revertable: false, dBit: true, 
            affectsActionId: 0, affectedByActionId: 0};
        
        let action_id_{{action.actionID}}_{{object.objID}} = h_util::action_hash(@action_{{action.actionID}}_{{object.objID}} );
        action_{{action.actionID}}_{{object.objID}}.actionId = action_id;

        
        {% endfor %}
        store_actions(w, array![{% for action in object.actions %}action_{{action.actionID}}_{{object.objID}}{% endfor %} ]);
        {% endif %}
        

        let mut object_{{object.objID}} = Object{
            objectId: st::SETME, 
            objType: zrk::ObjectType::Ball, // TODO
            dirType: zrk::DirectionType::None,  // TODO
            destId: st::NONE,  // TODO
            matType: zrk::MaterialType::Leather,  // TODO
            objectActionIds: array![{% for action in object.actions %}action_id_{{action.actionID}}_{{object.objID}}{% endfor %}],
            txtDefId: st::SETME 
         };

        let object_id = h_util::obj_hash(@object_{{object.objID}}); 
        object_{{object.objID}}.objectId = object_id;
        let ball_desc: ByteArray = "a knock off UEFA football\nits a bit battered and bruised\nnot exactly a sphere\nbut you can kick it";  // TODO
        let td_id_b = h_util::str_hash(@ball_desc); // text id
        object_{{object.objID}}.txtDefId = td_id_b;

        store_txt(w, td_id_b, ball_id, ball_desc);
        
        {% endfor %}
        store_objects(w, array![{% for object in room.objects %}object_{{object.objID}}{% endfor %}]);
        {% endif %}
        
        
        // now store a room with all its shizzle
        let room_desc: ByteArray = make_txt(rm::PLAIN); // TODO
        let _txt_id = h_util::str_hash(@room_desc);
        let place_name: ByteArray = "bensons plain";  // TODO
        let rmid = h_util::str_hash(@place_name);

        let mut place = Room{
            roomId: rmid,
            roomType: zrk::RoomType::Plain, // TODO
            txtDefId: _txt_id,
            shortTxt: place_name,
            objectIds: array![ball_id],
            dirObjIds: array![de_id, dn_id],
            players: array![]
        };

        // set main description text in world store
        // for the place/area/room
        store_txt(w, _txt_id, rmid, room_desc);
        store_places(w, array![place]);
        
    }
    {% endfor %}
}
